// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract PriorSwap is Ownable {
    IERC20 public priorToken;
    IERC20 public usdcToken;
    IERC20 public usdtToken;
    IERC20 public daiToken;
    IERC20 public wethToken;

    uint256 public constant PRIOR_TO_USDC_RATE = 5; // 1 PRIOR = 0.2 USDC
    uint256 public constant PRIOR_TO_USDT_RATE = 5;
    uint256 public constant PRIOR_TO_DAI_RATE = 5;
    uint256 public constant PRIOR_TO_WETH_RATE = 5; // 1 PRIOR = 0.2 WETH

    uint256 public constant FEE_BASIS_POINTS = 30; // 0.3% fee (30 / 10000)

    event SwapExecuted(address indexed user, string swapType, uint256 priorAmount, uint256 receivedAmount);

    constructor(
        address _priorToken,
        address _usdcToken,
        address _usdtToken,
        address _daiToken,
        address _wethToken
    ) Ownable(msg.sender) {
        priorToken = IERC20(_priorToken);
        usdcToken = IERC20(_usdcToken);
        usdtToken = IERC20(_usdtToken);
        daiToken = IERC20(_daiToken);
        wethToken = IERC20(_wethToken);
    }

    function _applyFee(uint256 amount) internal pure returns (uint256) {
        return amount - ((amount * FEE_BASIS_POINTS) / 10000);
    }

    function _swap(address tokenOut, uint256 rate, uint256 priorAmount, string memory swapType) internal {
        require(priorToken.balanceOf(msg.sender) >= priorAmount, "Insufficient PRIOR");
        uint256 rawAmount = priorAmount / rate;
        uint256 amountOut = _applyFee(rawAmount);
        require(IERC20(tokenOut).balanceOf(address(this)) >= amountOut, "Insufficient liquidity");

        priorToken.transferFrom(msg.sender, address(this), priorAmount);
        IERC20(tokenOut).transfer(msg.sender, amountOut);

        emit SwapExecuted(msg.sender, swapType, priorAmount, amountOut);
    }

    function swapPriorForUSDC(uint256 priorAmount) external {
        _swap(address(usdcToken), PRIOR_TO_USDC_RATE, priorAmount, "PRIOR to USDC");
    }

    function swapPriorForUSDT(uint256 priorAmount) external {
        _swap(address(usdtToken), PRIOR_TO_USDT_RATE, priorAmount, "PRIOR to USDT");
    }

    function swapPriorForDAI(uint256 priorAmount) external {
        _swap(address(daiToken), PRIOR_TO_DAI_RATE, priorAmount, "PRIOR to DAI");
    }

    function swapPriorForWETH(uint256 priorAmount) external {
        _swap(address(wethToken), PRIOR_TO_WETH_RATE, priorAmount, "PRIOR to wETH");
    }

    function fundSwapWithTokens(
        uint256 priorAmount,
        uint256 usdcAmount,
        uint256 usdtAmount,
        uint256 daiAmount,
        uint256 wethAmount
    ) external onlyOwner {
        priorToken.transferFrom(msg.sender, address(this), priorAmount);
        usdcToken.transferFrom(msg.sender, address(this), usdcAmount);
        usdtToken.transferFrom(msg.sender, address(this), usdtAmount);
        daiToken.transferFrom(msg.sender, address(this), daiAmount);
        wethToken.transferFrom(msg.sender, address(this), wethAmount);
    }

    function withdrawTokens(address token, uint256 amount) external onlyOwner {
        IERC20(token).transfer(msg.sender, amount);
    }
}
