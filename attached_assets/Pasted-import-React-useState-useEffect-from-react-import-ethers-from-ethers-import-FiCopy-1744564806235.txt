import React, { useState, useEffect } from "react";
import { ethers } from "ethers";
import { FiCopy, FiChevronDown, FiArrowDown, FiRefreshCw, FiSettings, FiExternalLink, FiLogOut } from "react-icons/fi";
import { useToast } from "@/hooks/use-toast";
import { useWallet } from "@/context/WalletContext";
import { TransactionHistory } from "@/components/TransactionHistory";

// Import contract functions and addresses from the reorganized structure
import { 
  swapTokens, 
  approveTokens,
  getPriorToUSDCRate,
  getPriorToUSDTRate,
  getTokenBalance as getTokenBalanceFromContract
} from "@/contracts/services";
import { CONTRACT_ADDRESSES as contractAddresses } from "@/contracts/addresses";

// Define token info
const TOKENS = {
  PRIOR: {
    address: contractAddresses.priorToken,
    symbol: "PRIOR",
    decimals: 18,
    logo: "P",
    color: "#00df9a"
  },
  USDC: {
    address: contractAddresses.tokens.USDC,
    symbol: "USDC",
    decimals: 6,
    logo: "U",
    color: "#2775CA"
  },
  USDT: {
    address: contractAddresses.tokens.USDT,
    symbol: "USDT",
    decimals: 6,
    logo: "U",
    color: "#26A17B"
  }
};

export default function Swap() {
  const { toast } = useToast();
  const { 
    address, 
    isConnected, 
    connectWallet, 
    disconnectWallet,
    getTokenBalance,
  } = useWallet();

  // State variables
  const [fromToken, setFromToken] = useState<string>("PRIOR");
  const [toToken, setToToken] = useState<string>("USDC");
  const [fromAmount, setFromAmount] = useState<string>("");
  const [toAmount, setToAmount] = useState<string>("0");
  const [balances, setBalances] = useState<{[key: string]: string}>({});
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [isApproving, setIsApproving] = useState<boolean>(false);
  const [isSwapping, setIsSwapping] = useState<boolean>(false);
  const [hasAllowance, setHasAllowance] = useState<boolean>(false);
  const [slippage, setSlippage] = useState<number>(0.5);
  const [showSettings, setShowSettings] = useState<boolean>(false);
  const [txHash, setTxHash] = useState<string>("");
  const [exchangeRates, setExchangeRates] = useState<{[key: string]: number}>({});
  const [showFromDropdown, setShowFromDropdown] = useState<boolean>(false);
  const [showToDropdown, setShowToDropdown] = useState<boolean>(false);
  const [provider, setProvider] = useState<ethers.providers.Web3Provider | null>(null);
  const [signer, setSigner] = useState<ethers.Signer | null>(null);
  const [directAddress, setDirectAddress] = useState<string | null>(null);
  const [isLocalConnected, setIsLocalConnected] = useState<boolean>(false);

  // Initialize provider and attempt to get the connected account directly
  useEffect(() => {
    const ethereum = typeof window !== 'undefined' && window.ethereum;
    
    if (ethereum) {
      try {
        const web3Provider = new ethers.providers.Web3Provider(ethereum);
        setProvider(web3Provider);

        ethereum.on('accountsChanged', (accounts: string[]) => {
          if (accounts && accounts.length > 0) {
            setDirectAddress(accounts[0]);
            setIsLocalConnected(true);
            handleAccountsChanged(accounts);
          } else {
            setDirectAddress(null);
            setIsLocalConnected(false);
          }
        });

        ethereum.on('chainChanged', handleChainChanged);
        
        ethereum.request({ method: "eth_accounts" })
          .then((accounts: any) => {
            if (accounts && accounts.length > 0) {
              setDirectAddress(accounts[0]);
              setIsLocalConnected(true);
              loadBalances(accounts[0]);
              try {
                const signerInstance = web3Provider.getSigner();
                setSigner(signerInstance);
              } catch (signerError) {
                console.error("Error getting signer:", signerError);
              }
            }
          })
          .catch((error: any) => {
            console.error("Error checking accounts:", error);
          });
        
        web3Provider.listAccounts()
          .then(accounts => {
            if (accounts && accounts.length > 0) {
              setDirectAddress(accounts[0]);
              setIsLocalConnected(true);
              handleAccountsChanged(accounts);
              if (!signer) {
                try {
                  const signerInstance = web3Provider.getSigner();
                  setSigner(signerInstance);
                } catch (signerError) {
                  console.error("Error getting signer:", signerError);
                }
              }
            }
          })
          .catch(error => {
            console.error("Error checking accounts:", error);
          });
        
        return () => {
          ethereum.removeAllListeners('accountsChanged');
          ethereum.removeAllListeners('chainChanged');
        };
      } catch (error) {
        console.error("Error initializing provider:", error);
      }
    }
  }, []);

  const handleAccountsChanged = async (accounts: string[]) => {
    if (accounts.length === 0) {
      setDirectAddress(null);
      setIsLocalConnected(false);
      setBalances({});
    } else {
      setDirectAddress(accounts[0]);
      setIsLocalConnected(true);
      await loadBalances(accounts[0]);
    }
  };

  const handleChainChanged = () => {
    window.location.reload();
  };

  const manualConnectWallet = async () => {
    try {
      setIsLoading(true);
      
      if (window.ethereum) {
        try {
          const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
          
          if (accounts && accounts.length > 0) {
            const connectedAddress = accounts[0];
            setDirectAddress(connectedAddress);
            
            const chainId = await window.ethereum.request({ method: 'eth_chainId' });
            const desiredChainId = '0x14a34'; // Base Sepolia
            
            if (chainId !== desiredChainId) {
              try {
                await window.ethereum.request({
                  method: 'wallet_switchEthereumChain',
                  params: [{ chainId: desiredChainId }],
                });
              } catch (switchError: any) {
                if (switchError.code === 4902) {
                  await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                      chainId: desiredChainId,
                      chainName: 'Base Sepolia',
                      nativeCurrency: {
                        name: 'ETH',
                        symbol: 'ETH',
                        decimals: 18
                      },
                      rpcUrls: ['https://sepolia.base.org'],
                      blockExplorerUrls: ['https://sepolia-explorer.base.org']
                    }]
                  });
                }
              }
            }
            
            if (window.ethereum) {
              const web3Provider = new ethers.providers.Web3Provider(window.ethereum);
              setProvider(web3Provider);
              
              try {
                const signerInstance = web3Provider.getSigner();
                setSigner(signerInstance);
                await loadBalances(connectedAddress);
                await loadExchangeRates();
                
                toast({
                  title: "Wallet Connected",
                  description: `Connected to ${connectedAddress.substring(0, 6)}...${connectedAddress.substring(connectedAddress.length - 4)}`,
                });
                
                setIsLocalConnected(true);
              } catch (signerError) {
                console.error("Error getting signer:", signerError);
              }
            }
          }
        } catch (requestError) {
          console.error("Error requesting accounts:", requestError);
          toast({
            title: "Connection Error",
            description: "MetaMask account request was rejected.",
            variant: "destructive"
          });
        }
      } else {
        toast({
          title: "MetaMask Not Found",
          description: "Please install MetaMask extension.",
          variant: "destructive"
        });
      }
    } catch (error) {
      console.error("Error in wallet connection:", error);
      toast({
        title: "Connection Error",
        description: "Failed to connect wallet.",
        variant: "destructive"
      });
    } finally {
      setIsLoading(false);
    }
  };

  // Load token balances
  const loadBalances = async (walletAddress: string) => {
    const newBalances: {[key: string]: string} = {};
    
    try {
      if (provider) {
        for (const symbol of Object.keys(TOKENS)) {
          try {
            const tokenAddress = TOKENS[symbol as keyof typeof TOKENS].address;
            const balance = await getTokenBalanceFromContract(tokenAddress, walletAddress);
            newBalances[symbol] = balance;
          } catch (tokenError) {
            console.error(`Error getting ${symbol} balance:`, tokenError);
            newBalances[symbol] = "0";
          }
        }
      } else {
        for (const symbol of Object.keys(TOKENS)) {
          const balance = getTokenBalance(symbol);
          newBalances[symbol] = balance;
        }
      }
      
      setBalances(newBalances);
    } catch (error) {
      console.error("Error loading balances:", error);
    }
  };

  // Load exchange rates from contract
  const loadExchangeRates = async () => {
    try {
      const [priorToUsdcRate, priorToUsdtRate] = await Promise.all([
        getPriorToUSDCRate(),
        getPriorToUSDTRate()
      ]);
      
      const priorUsdcValue = typeof priorToUsdcRate === 'string' ? priorToUsdcRate : '10';
      const priorUsdtValue = typeof priorToUsdtRate === 'string' ? priorToUsdtRate : '10';

      const usdcPriorValue = (1 / parseFloat(priorUsdcValue)).toString();
      const usdtPriorValue = (1 / parseFloat(priorUsdtValue)).toString();

      setExchangeRates({
        PRIOR_USDC: parseFloat(priorUsdcValue),
        PRIOR_USDT: parseFloat(priorUsdtValue),
        USDC_PRIOR: parseFloat(usdcPriorValue),
        USDT_PRIOR: parseFloat(usdtPriorValue),
        USDC_USDT: 1,
        USDT_USDC: 1
      });
    } catch (error) {
      console.error("Error loading exchange rates:", error);
      setExchangeRates({
        PRIOR_USDC: 10,
        PRIOR_USDT: 10,
        USDC_PRIOR: 0.1,
        USDT_PRIOR: 0.1,
        USDC_USDT: 1,
        USDT_USDC: 1
      });
    }
  };

  // Get swap contract address
  const getSwapContractAddress = (fromTok: string, toTok: string): string => {
    const pair = [fromTok, toTok].sort().join('_');
    
    if (pair === 'PRIOR_USDC') {
      return contractAddresses.swapContracts.PRIOR_USDC;
    } else if (pair === 'PRIOR_USDT') {
      return contractAddresses.swapContracts.PRIOR_USDT;
    } else if (pair === 'USDC_USDT') {
      return contractAddresses.swapContracts.USDC_USDT;
    } else {
      console.error(`No swap contract found for pair: ${fromTok}-${toTok}`);
      return '';
    }
  };

  // Check allowance
  const checkAllowance = async () => {
    const walletAddress = directAddress || address;
    if (!walletAddress || !fromAmount || !provider) return;
    
    try {
      const tokenAddress = TOKENS[fromToken as keyof typeof TOKENS].address;
      const tokenDecimals = TOKENS[fromToken as keyof typeof TOKENS].decimals;
      const tokenContract = new ethers.Contract(
        tokenAddress,
        ["function allowance(address owner, address spender) view returns (uint256)"],
        provider
      );
      
      const swapContractAddress = getSwapContractAddress(fromToken, toToken);
      if (!swapContractAddress) {
        setHasAllowance(false);
        return;
      }
      
      const allowance = await tokenContract.allowance(walletAddress, swapContractAddress);
      const amountWei = ethers.utils.parseUnits(fromAmount, tokenDecimals);
      
      setHasAllowance(allowance.gte(amountWei));
    } catch (error) {
      console.error("Error checking allowance:", error);
      setHasAllowance(false);
    }
  };

  // Approve token spending - UPDATED TO HANDLE BIGNUMBERS PROPERLY
  const approveToken = async () => {
    if (!signer || !fromAmount) return;
    
    setIsApproving(true);
    try {
      const tokenAddress = TOKENS[fromToken as keyof typeof TOKENS].address;
      const tokenDecimals = TOKENS[fromToken as keyof typeof TOKENS].decimals;
      
      const swapContractAddress = getSwapContractAddress(fromToken, toToken);
      if (!swapContractAddress) {
        throw new Error(`No swap contract available for ${fromToken}-${toToken} pair`);
      }
      
      // Convert the amount to approve to the proper BigNumber format
      const amountToApprove = ethers.utils.parseUnits(fromAmount, tokenDecimals);
      // Approve 100x the amount being swapped
      const approvalAmount = amountToApprove.mul(100);
      
      console.log(`Approving ${ethers.utils.formatUnits(approvalAmount, tokenDecimals)} ${fromToken}`);
      
      // Pass the BigNumber value to the approve function
      await approveTokens(tokenAddress, swapContractAddress, approvalAmount);
      
      setHasAllowance(true);
      toast({
        title: "Approval Successful",
        description: `Successfully approved ${fromToken} for trading.`,
      });
    } catch (error: any) {
      console.error("Error approving token:", error);
      toast({
        title: "Approval Failed",
        description: error.message || "Failed to approve token.",
        variant: "destructive"
      });
    } finally {
      setIsApproving(false);
    }
  };

  // Execute swap - UPDATED TO HANDLE BIGNUMBERS PROPERLY
  const executeSwap = async () => {
    if (!signer || !fromAmount || !hasAllowance) return;
    
    setIsSwapping(true);
    try {
      const fromTokenInfo = TOKENS[fromToken as keyof typeof TOKENS];
      const toTokenInfo = TOKENS[toToken as keyof typeof TOKENS];
      
      // Convert input amount to proper BigNumber format
      const amountIn = ethers.utils.parseUnits(fromAmount, fromTokenInfo.decimals);
      
      // Calculate minimum amount out with slippage
      const slippageFactor = 1 - (slippage / 100);
      const amountOut = ethers.utils.parseUnits(toAmount, toTokenInfo.decimals);
      const minAmountOut = amountOut.mul(Math.floor(slippageFactor * 10000)).div(10000);
      
      const swapContractAddress = getSwapContractAddress(fromToken, toToken);
      if (!swapContractAddress) {
        throw new Error(`No swap contract available for ${fromToken}-${toToken} pair`);
      }
      
      // Perform swap with proper BigNumber values
      const txReceipt = await swapTokens(
        fromTokenInfo.address,
        toTokenInfo.address,
        amountIn,
        swapContractAddress,
        minAmountOut
      );
      
      if (txReceipt) {
        const hash = typeof txReceipt === 'object' && txReceipt.transactionHash 
          ? txReceipt.transactionHash 
          : '';
        setTxHash(hash);
        toast({
          title: "Swap Successful",
          description: `Successfully swapped ${fromAmount} ${fromToken} for approximately ${parseFloat(toAmount).toFixed(6)} ${toToken}`,
        });
        
        const currentAddress = directAddress || address;
        if (currentAddress) {
          await loadBalances(currentAddress);
        }
        
        setFromAmount("");
        setToAmount("0");
      }
    } catch (error: any) {
      console.error("Error executing swap:", error);
      let errorMessage = "Failed to execute swap. Please try again.";
      
      if (error.reason && error.reason.includes("Insufficient liquidity")) {
        errorMessage = "Insufficient liquidity in the pool. Try a smaller amount.";
      } else if (error.message && error.message.includes("user rejected")) {
        errorMessage = "Transaction rejected by user.";
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      toast({
        title: "Swap Failed",
        description: errorMessage,
        variant: "destructive"
      });
    } finally {
      setIsSwapping(false);
    }
  };

  // Calculate expected output amount
  useEffect(() => {
    if (!fromAmount || isNaN(parseFloat(fromAmount))) {
      setToAmount("0");
      return;
    }

    try {
      const amount = parseFloat(fromAmount);
      const rateKey = `${fromToken}_${toToken}`;
      const rate = exchangeRates[rateKey] || 0;
      
      if (rate <= 0) {
        setToAmount("0");
        return;
      }

      const result = amount * rate;
      
      const targetDecimals = TOKENS[toToken as keyof typeof TOKENS].decimals;
      
      if ((fromToken === "USDC" && toToken === "USDT") || (fromToken === "USDT" && toToken === "USDC")) {
        setToAmount(fromAmount);
      } 
      else if (fromToken === "PRIOR" && (toToken === "USDC" || toToken === "USDT")) {
        setToAmount(result.toFixed(2));
      }
      else if ((fromToken === "USDC" || fromToken === "USDT") && toToken === "PRIOR") {
        setToAmount(result.toFixed(4));
      }
      else {
        setToAmount(result.toFixed(4));
      }
    } catch (error) {
      console.error("Calculation error:", error);
      setToAmount("0");
    }
  }, [fromAmount, fromToken, toToken, exchangeRates, slippage]);

  // Check allowance when inputs change
  useEffect(() => {
    checkAllowance();
  }, [directAddress, address, fromToken, fromAmount]);

  // Update balances when address changes
  useEffect(() => {
    const currentAddress = directAddress || address;
    
    if (currentAddress) {
      loadBalances(currentAddress);
      
      if (provider && !signer) {
        try {
          const signerInstance = provider.getSigner();
          setSigner(signerInstance);
        } catch (error) {
          console.error("Error getting signer:", error);
        }
      }
    }
  }, [directAddress, address, provider, signer]);

  // Load exchange rates on first render
  useEffect(() => {
    loadExchangeRates();
  }, []);

  // Handle token selection
  const handleFromTokenSelect = (token: string) => {
    if (token === toToken) {
      setToToken(fromToken);
    }
    setFromToken(token);
    setShowFromDropdown(false);
  };

  const handleToTokenSelect = (token: string) => {
    if (token === fromToken) {
      setFromToken(toToken);
    }
    setToToken(token);
    setShowToDropdown(false);
  };

  // Switch tokens
  const switchTokens = () => {
    const temp = fromToken;
    setFromToken(toToken);
    setToToken(temp);
    
    if (toAmount && toAmount !== "0") {
      setFromAmount(toAmount);
    }
  };

  // Set max amount
  const setMaxAmount = () => {
    setFromAmount(balances[fromToken] || "0");
  };

  // Format balance display
  const formatBalance = (balance: string, tokenSymbol?: string) => {
    const token = tokenSymbol || "PRIOR";
    const decimals = TOKENS[token as keyof typeof TOKENS]?.decimals || 18;
    const displayDecimals = decimals === 6 ? 2 : 4;
    return parseFloat(balance || "0").toFixed(displayDecimals);
  };

  // Get available tokens for dropdown
  const getAvailableTokens = (excludeToken: string) => {
    return Object.keys(TOKENS).filter(token => token !== excludeToken);
  };

  // Verify if the pair is supported
  const isPairSupported = () => {
    if (fromToken === "PRIOR" || toToken === "PRIOR") {
      return true;
    }
    
    if ((fromToken === "USDC" && toToken === "USDT") || (fromToken === "USDT" && toToken === "USDC")) {
      return true;
    }
    
    return false;
  };

  // ... (rest of the JSX remains the same)
  return (
    <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center p-4">
      {/* Your existing JSX here - it doesn't need changes */}
    </div>
  );
}