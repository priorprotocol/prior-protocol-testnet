import React, { useState, useEffect } from "react";
import { ethers } from "ethers";
import { FiCopy, FiChevronDown, FiArrowDown, FiRefreshCw, FiSettings, FiExternalLink } from "react-icons/fi";

// Contract addresses
const PRIOR_SWAP_ADDRESS = "0x95762B35E9f5631F37b69F4418C500Aba05626bf";
const PRIOR_TOKEN_ADDRESS = "0x15b5Cca71598A1e2f5C8050ef3431dCA49F8EcbD";
const USDC_TOKEN_ADDRESS = "0x0C6BAA4B8092B29F6B370e06BdfE67434680E062";
const USDT_TOKEN_ADDRESS = "0xdaDcC45A00fe893df95488622fA2B64BfFc5E0bf";
const DAI_TOKEN_ADDRESS = "0x72f30eb1cE25523Ea2Fa63eDe9797481634E496B";
const WETH_TOKEN_ADDRESS = "0xc413B81c5fb4798b8e4c6053AADd383C4Dc3703B";

// ABI from your provided contract
const PRIOR_SWAP_ABI = [
  // ... (use the full ABI you provided)
];

const ERC20_ABI = [
  "function balanceOf(address owner) view returns (uint256)",
  "function decimals() view returns (uint8)",
  "function symbol() view returns (string)",
  "function approve(address spender, uint256 amount) returns (bool)",
  "function allowance(address owner, address spender) view returns (uint256)"
];

const MAX_UINT256 = ethers.MaxUint256.toString();

const TOKENS = {
  PRIOR: {
    address: PRIOR_TOKEN_ADDRESS,
    symbol: "PRIOR",
    decimals: 18,
    logo: "https://placehold.co/40/00df9a/white?text=P",
    color: "#00df9a"
  },
  USDC: {
    address: USDC_TOKEN_ADDRESS,
    symbol: "USDC",
    decimals: 6,
    logo: "https://placehold.co/40/2775CA/white?text=U",
    color: "#2775CA"
  },
  USDT: {
    address: USDT_TOKEN_ADDRESS,
    symbol: "USDT",
    decimals: 6,
    logo: "https://placehold.co/40/26A17B/white?text=U",
    color: "#26A17B"
  },
  DAI: {
    address: DAI_TOKEN_ADDRESS,
    symbol: "DAI",
    decimals: 18,
    logo: "https://placehold.co/40/F5AC37/white?text=D",
    color: "#F5AC37"
  },
  WETH: {
    address: WETH_TOKEN_ADDRESS,
    symbol: "WETH",
    decimals: 18,
    logo: "https://placehold.co/40/627EEA/white?text=W",
    color: "#627EEA"
  }
};

const Swap = () => {
  // State variables
  const [account, setAccount] = useState(null);
  const [provider, setProvider] = useState(null);
  const [signer, setSigner] = useState(null);
  const [balances, setBalances] = useState({});
  const [fromToken, setFromToken] = useState("PRIOR");
  const [toToken, setToToken] = useState("USDC");
  const [fromAmount, setFromAmount] = useState("");
  const [toAmount, setToAmount] = useState("0");
  const [isLoading, setIsLoading] = useState(false);
  const [isApproving, setIsApproving] = useState(false);
  const [isSwapping, setIsSwapping] = useState(false);
  const [hasAllowance, setHasAllowance] = useState(false);
  const [slippage, setSlippage] = useState(0.5); // 0.5% default slippage
  const [showSettings, setShowSettings] = useState(false);
  const [txHash, setTxHash] = useState("");
  const [exchangeRates, setExchangeRates] = useState({});
  const [showFromDropdown, setShowFromDropdown] = useState(false);
  const [showToDropdown, setShowToDropdown] = useState(false);

  // Initialize provider
  useEffect(() => {
    if (window.ethereum) {
      const initProvider = new ethers.BrowserProvider(window.ethereum);
      setProvider(initProvider);

      window.ethereum.on('accountsChanged', handleAccountsChanged);
      window.ethereum.on('chainChanged', handleChainChanged);
    }
  }, []);

  const handleAccountsChanged = (accounts) => {
    if (accounts.length === 0) {
      // Wallet disconnected
      setAccount(null);
      setBalances({});
    } else {
      setAccount(accounts[0]);
      loadBalances(accounts[0]);
    }
  };

  const handleChainChanged = () => {
    window.location.reload();
  };

  // Connect wallet
  const connectWallet = async () => {
    if (!provider) return;
    
    try {
      setIsLoading(true);
      const accounts = await provider.send("eth_requestAccounts", []);
      const signer = await provider.getSigner();
      
      setAccount(accounts[0]);
      setSigner(signer);
      await loadBalances(accounts[0]);
      await loadExchangeRates();
    } catch (error) {
      console.error("Error connecting wallet:", error);
    } finally {
      setIsLoading(false);
    }
  };

  // Load token balances
  const loadBalances = async (walletAddress) => {
    const newBalances = {};
    
    try {
      for (const [symbol, token] of Object.entries(TOKENS)) {
        const contract = new ethers.Contract(token.address, ERC20_ABI, provider);
        const balance = await contract.balanceOf(walletAddress);
        newBalances[symbol] = ethers.formatUnits(balance, token.decimals);
      }
      
      setBalances(newBalances);
    } catch (error) {
      console.error("Error loading balances:", error);
    }
  };

  // Load exchange rates from contract
  const loadExchangeRates = async () => {
    try {
      const swapContract = new ethers.Contract(PRIOR_SWAP_ADDRESS, PRIOR_SWAP_ABI, provider);
      
      const [
        priorToUsdcRate, 
        priorToUsdtRate, 
        priorToDaiRate, 
        priorToWethRate
      ] = await Promise.all([
        swapContract.PRIOR_TO_USDC_RATE(),
        swapContract.PRIOR_TO_USDT_RATE(),
        swapContract.PRIOR_TO_DAI_RATE(),
        swapContract.PRIOR_TO_WETH_RATE()
      ]);

      // Calculate inverse rates for swapping from stablecoins to PRIOR
      const usdcToPriorRate = 10n ** 36n / priorToUsdcRate;
      const usdtToPriorRate = 10n ** 36n / priorToUsdtRate;
      const daiToPriorRate = 10n ** 36n / priorToDaiRate;
      const wethToPriorRate = 10n ** 36n / priorToWethRate;

      setExchangeRates({
        PRIOR_USDC: parseFloat(ethers.formatUnits(priorToUsdcRate, 6)),
        PRIOR_USDT: parseFloat(ethers.formatUnits(priorToUsdtRate, 6)),
        PRIOR_DAI: parseFloat(ethers.formatUnits(priorToDaiRate, 18)),
        PRIOR_WETH: parseFloat(ethers.formatUnits(priorToWethRate, 18)),
        USDC_PRIOR: parseFloat(ethers.formatUnits(usdcToPriorRate, 18)),
        USDT_PRIOR: parseFloat(ethers.formatUnits(usdtToPriorRate, 18)),
        DAI_PRIOR: parseFloat(ethers.formatUnits(daiToPriorRate, 18)),
        WETH_PRIOR: parseFloat(ethers.formatUnits(wethToPriorRate, 18))
      });
    } catch (error) {
      console.error("Error loading exchange rates:", error);
    }
  };

  // Check token allowance
  const checkAllowance = async () => {
    if (!account || !fromAmount) return;
    
    try {
      const tokenContract = new ethers.Contract(
        TOKENS[fromToken].address, 
        ERC20_ABI, 
        provider
      );
      
      const allowance = await tokenContract.allowance(account, PRIOR_SWAP_ADDRESS);
      const amountWei = ethers.parseUnits(fromAmount, TOKENS[fromToken].decimals);
      
      setHasAllowance(allowance >= amountWei);
    } catch (error) {
      console.error("Error checking allowance:", error);
      setHasAllowance(false);
    }
  };

  // Approve token spending
  const approveToken = async () => {
    if (!signer || !fromAmount) return;
    
    setIsApproving(true);
    try {
      const tokenContract = new ethers.Contract(
        TOKENS[fromToken].address, 
        ERC20_ABI, 
        signer
      );
      
      const tx = await tokenContract.approve(PRIOR_SWAP_ADDRESS, MAX_UINT256);
      await tx.wait();
      setHasAllowance(true);
    } catch (error) {
      console.error("Error approving token:", error);
    } finally {
      setIsApproving(false);
    }
  };

  // Execute swap
  const executeSwap = async () => {
    if (!signer || !fromAmount || !hasAllowance) return;
    
    setIsSwapping(true);
    try {
      const swapContract = new ethers.Contract(PRIOR_SWAP_ADDRESS, PRIOR_SWAP_ABI, signer);
      const amountWei = ethers.parseUnits(fromAmount, TOKENS[fromToken].decimals);
      let tx;

      if (fromToken === "PRIOR") {
        switch(toToken) {
          case "USDC": 
            tx = await swapContract.swapPriorForUSDC(amountWei); 
            break;
          case "USDT": 
            tx = await swapContract.swapPriorForUSDT(amountWei); 
            break;
          case "DAI": 
            tx = await swapContract.swapPriorForDAI(amountWei); 
            break;
          case "WETH": 
            tx = await swapContract.swapPriorForWETH(amountWei); 
            break;
          default: 
            throw new Error("Unsupported token pair");
        }
      } else {
        switch(fromToken) {
          case "USDC": 
            tx = await swapContract.swapUSDCForPrior(amountWei); 
            break;
          case "USDT": 
            tx = await swapContract.swapUSDTForPrior(amountWei); 
            break;
          case "DAI": 
            tx = await swapContract.swapDAIForPrior(amountWei); 
            break;
          case "WETH": 
            tx = await swapContract.swapWETHForPrior(amountWei); 
            break;
          default: 
            throw new Error("Unsupported token pair");
        }
      }

      setTxHash(tx.hash);
      await tx.wait();
      
      // Refresh balances after swap
      await loadBalances(account);
      setFromAmount("");
    } catch (error) {
      console.error("Error executing swap:", error);
    } finally {
      setIsSwapping(false);
    }
  };

  // Calculate expected output amount
  useEffect(() => {
    if (!fromAmount || isNaN(parseFloat(fromAmount))) {
      setToAmount("0");
      return;
    }

    try {
      const amount = parseFloat(fromAmount);
      const rateKey = `${fromToken}_${toToken}`;
      const rate = exchangeRates[rateKey] || 0;
      
      if (rate <= 0) {
        setToAmount("0");
        return;
      }

      // Apply slippage
      const slippageMultiplier = 1 - (slippage / 100);
      const result = amount * rate * slippageMultiplier;
      
      // Format based on token decimals
      const formattedResult = result.toFixed(TOKENS[toToken].decimals > 6 ? 6 : TOKENS[toToken].decimals);
      setToAmount(formattedResult);
    } catch (error) {
      console.error("Calculation error:", error);
      setToAmount("0");
    }
  }, [fromAmount, fromToken, toToken, exchangeRates, slippage]);

  // Check allowance when inputs change
  useEffect(() => {
    checkAllowance();
  }, [account, fromToken, fromAmount]);

  // Handle token selection
  const handleFromTokenSelect = (token) => {
    if (token === toToken) {
      setToToken(fromToken);
    }
    setFromToken(token);
    setShowFromDropdown(false);
  };

  const handleToTokenSelect = (token) => {
    if (token === fromToken) {
      setFromToken(toToken);
    }
    setToToken(token);
    setShowToDropdown(false);
  };

  // Switch tokens
  const switchTokens = () => {
    const temp = fromToken;
    setFromToken(toToken);
    setToToken(temp);
  };

  // Set max amount
  const setMaxAmount = () => {
    setFromAmount(balances[fromToken] || "0");
  };

  // Format balance display
  const formatBalance = (balance) => {
    return parseFloat(balance).toFixed(4);
  };

  // Get available tokens for dropdown
  const getAvailableTokens = (excludeToken) => {
    return Object.keys(TOKENS).filter(token => token !== excludeToken);
  };

  return (
    <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center p-4">
      <div className="w-full max-w-md">
        {/* Header */}
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-2xl font-bold">PRIOR Swap</h1>
          <div className="flex items-center space-x-2">
            <button 
              onClick={() => setShowSettings(!showSettings)}
              className="p-2 rounded-full hover:bg-gray-800 transition-colors"
            >
              <FiSettings className="w-5 h-5" />
            </button>
            {account ? (
              <div className="flex items-center bg-gray-800 rounded-full px-3 py-1">
                <span className="text-sm mr-2">
                  {`${account.substring(0, 6)}...${account.substring(38)}`}
                </span>
                <button 
                  onClick={() => navigator.clipboard.writeText(account)}
                  className="text-gray-400 hover:text-white"
                >
                  <FiCopy className="w-4 h-4" />
                </button>
              </div>
            ) : (
              <button
                onClick={connectWallet}
                className="bg-gradient-to-r from-[#00df9a] to-blue-500 text-black font-medium px-4 py-2 rounded-full hover:opacity-90 transition-opacity"
              >
                Connect Wallet
              </button>
            )}
          </div>
        </div>

        {/* Swap Card */}
        <div className="bg-gray-800 rounded-2xl p-4 shadow-xl border border-gray-700">
          {/* Settings Panel */}
          {showSettings && (
            <div className="bg-gray-700 rounded-xl p-4 mb-4">
              <h3 className="font-medium mb-3">Transaction Settings</h3>
              <div className="space-y-3">
                <div>
                  <label className="block text-sm text-gray-400 mb-1">Slippage Tolerance</label>
                  <div className="flex space-x-2">
                    {[0.1, 0.5, 1].map((value) => (
                      <button
                        key={value}
                        onClick={() => setSlippage(value)}
                        className={`px-3 py-1 rounded-lg text-sm ${slippage === value ? 'bg-[#00df9a] text-black' : 'bg-gray-600 hover:bg-gray-500'}`}
                      >
                        {value}%
                      </button>
                    ))}
                    <div className="relative flex-1">
                      <input
                        type="number"
                        value={slippage}
                        onChange={(e) => {
                          const value = parseFloat(e.target.value) || 0;
                          setSlippage(Math.max(0, Math.min(100, value)));
                        }}
                        className="w-full bg-gray-600 rounded-lg px-3 py-1 text-right text-sm focus:outline-none focus:ring-1 focus:ring-[#00df9a]"
                        min="0"
                        max="100"
                        step="0.1"
                      />
                      <span className="absolute right-3 top-1/2 transform -translate-y-1/2 text-sm text-gray-300">%</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* From Token */}
          <div className="bg-gray-700 rounded-xl p-3 mb-2">
            <div className="flex justify-between items-center mb-1">
              <span className="text-sm text-gray-400">From</span>
              <button 
                onClick={setMaxAmount}
                className="text-xs bg-gray-600 hover:bg-gray-500 px-2 py-0.5 rounded"
              >
                Max: {formatBalance(balances[fromToken] || "0")}
              </button>
            </div>
            <div className="flex items-center">
              <input
                type="number"
                value={fromAmount}
                onChange={(e) => setFromAmount(e.target.value)}
                placeholder="0.0"
                className="bg-transparent text-2xl w-full outline-none"
              />
              <div className="relative">
                <button 
                  onClick={() => setShowFromDropdown(!showFromDropdown)}
                  className="flex items-center gap-2 bg-gray-600 hover:bg-gray-500 px-3 py-2 rounded-lg ml-2 transition-colors"
                >
                  <img src={TOKENS[fromToken].logo} alt={fromToken} className="w-6 h-6 rounded-full" />
                  <span>{TOKENS[fromToken].symbol}</span>
                  <FiChevronDown className="text-gray-300" />
                </button>
                {showFromDropdown && (
                  <div className="absolute right-0 mt-2 w-full bg-gray-800 rounded-xl shadow-lg z-10 border border-gray-700 max-h-60 overflow-auto">
                    {getAvailableTokens(toToken).map(token => (
                      <button
                        key={token}
                        onClick={() => handleFromTokenSelect(token)}
                        className="w-full text-left px-4 py-3 hover:bg-gray-700 flex items-center gap-3"
                      >
                        <img src={TOKENS[token].logo} alt={token} className="w-6 h-6 rounded-full" />
                        <span>{TOKENS[token].symbol}</span>
                      </button>
                    ))}
                  </div>
                )}
              </div>
            </div>
          </div>

          {/* Swap Direction Button */}
          <div className="flex justify-center my-1">
            <button
              onClick={switchTokens}
              className="p-2 bg-gray-700 hover:bg-gray-600 rounded-full -my-3 z-10 border-2 border-gray-800"
            >
              <FiArrowDown className="w-4 h-4" />
            </button>
          </div>

          {/* To Token */}
          <div className="bg-gray-700 rounded-xl p-3 mt-2">
            <div className="flex justify-between items-center mb-1">
              <span className="text-sm text-gray-400">To</span>
              <span className="text-xs text-gray-400">
                Balance: {formatBalance(balances[toToken] || "0")}
              </span>
            </div>
            <div className="flex items-center">
              <input
                type="text"
                value={toAmount}
                readOnly
                className="bg-transparent text-2xl w-full outline-none"
              />
              <div className="relative">
                <button 
                  onClick={() => setShowToDropdown(!showToDropdown)}
                  className="flex items-center gap-2 bg-gray-600 hover:bg-gray-500 px-3 py-2 rounded-lg ml-2 transition-colors"
                >
                  <img src={TOKENS[toToken].logo} alt={toToken} className="w-6 h-6 rounded-full" />
                  <span>{TOKENS[toToken].symbol}</span>
                  <FiChevronDown className="text-gray-300" />
                </button>
                {showToDropdown && (
                  <div className="absolute right-0 mt-2 w-full bg-gray-800 rounded-xl shadow-lg z-10 border border-gray-700 max-h-60 overflow-auto">
                    {getAvailableTokens(fromToken).map(token => (
                      <button
                        key={token}
                        onClick={() => handleToTokenSelect(token)}
                        className="w-full text-left px-4 py-3 hover:bg-gray-700 flex items-center gap-3"
                      >
                        <img src={TOKENS[token].logo} alt={token} className="w-6 h-6 rounded-full" />
                        <span>{TOKENS[token].symbol}</span>
                      </button>
                    ))}
                  </div>
                )}
              </div>
            </div>
          </div>

          {/* Rate Info */}
          <div className="text-sm text-gray-400 mt-3 px-1">
            <div className="flex justify-between">
              <span>Rate</span>
              <span>
                1 {TOKENS[fromToken].symbol} = {exchangeRates[`${fromToken}_${toToken}`]?.toFixed(6) || '0'} {TOKENS[toToken].symbol}
              </span>
            </div>
            <div className="flex justify-between mt-1">
              <span>Slippage</span>
              <span>{slippage}%</span>
            </div>
          </div>

          {/* Action Button */}
          <div className="mt-4">
            {!account ? (
              <button
                onClick={connectWallet}
                className="w-full bg-gradient-to-r from-[#00df9a] to-blue-500 text-black font-medium py-3 rounded-xl hover:opacity-90 transition-opacity"
              >
                Connect Wallet
              </button>
            ) : parseFloat(fromAmount) > parseFloat(balances[fromToken] || "0") ? (
              <button 
                disabled
                className="w-full bg-gray-700 text-gray-400 font-medium py-3 rounded-xl"
              >
                Insufficient {TOKENS[fromToken].symbol} balance
              </button>
            ) : !hasAllowance ? (
              <button 
                onClick={approveToken}
                disabled={isApproving || !fromAmount}
                className={`w-full ${isApproving ? 'bg-gray-600' : 'bg-gradient-to-r from-blue-600 to-blue-500'} text-white font-medium py-3 rounded-xl transition-colors`}
              >
                {isApproving ? (
                  <span className="flex items-center justify-center">
                    <FiRefreshCw className="animate-spin mr-2" />
                    Approving...
                  </span>
                ) : `Approve ${TOKENS[fromToken].symbol}`}
              </button>
            ) : (
              <button
                onClick={executeSwap}
                disabled={isSwapping || !fromAmount}
                className={`w-full ${isSwapping ? 'bg-gray-600' : 'bg-gradient-to-r from-[#00df9a] to-blue-500'} text-black font-medium py-3 rounded-xl transition-colors`}
              >
                {isSwapping ? (
                  <span className="flex items-center justify-center">
                    <FiRefreshCw className="animate-spin mr-2" />
                    Swapping...
                  </span>
                ) : `Swap to ${TOKENS[toToken].symbol}`}
              </button>
            )}
          </div>
        </div>

        {/* Transaction Link */}
        {txHash && (
          <div className="mt-4 text-center">
            <a
              href={`https://sepolia-explorer.base.org/tx/${txHash}`}
              target="_blank"
              rel="noopener noreferrer"
              className="text-[#00df9a] inline-flex items-center text-sm"
            >
              View transaction on explorer <FiExternalLink className="ml-1" />
            </a>
          </div>
        )}
      </div>
    </div>
  );
};

export default Swap;